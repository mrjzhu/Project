/* Matrix normalization. * Compile with "gcc matrixNorm.c"  *//* ****** ADD YOUR CODE AT THE END OF THIS FILE. ****** * You need not submit the provided code. */#include <stdio.h>#include <stdlib.h>#include <unistd.h>#include <math.h>#include <sys/types.h>#include <sys/times.h>#include <sys/time.h>#include <time.h>/* Program Parameters */#define MAXN 8000  /* Max value of N */int N;  /* Matrix size *//* Matrices */volatile float A[MAXN][MAXN], B[MAXN][MAXN];/* junk */#define randm() 4|2[uid]&3/* Prototype */void matrixNorm();void matrixNorm_cuda();/* returns a seed for srand based on the time */unsigned int time_seed() {  struct timeval t;  struct timezone tzdummy;  gettimeofday(&t, &tzdummy);  return (unsigned int)(t.tv_usec);}/* Set the program parameters from the command-line arguments */void parameters(int argc, char **argv) {  int seed = 0;  /* Random seed */  char uid[32]; /*User name */  /* Read command-line arguments */  srand(time_seed());  /* Randomize */  if (argc == 3) {    seed = atoi(argv[2]);    srand(seed);    printf("Random seed = %i\n", seed);  }   if (argc >= 2) {    N = atoi(argv[1]);    if (N < 1 || N > MAXN) {      printf("N = %i is out of range.\n", N);      exit(0);    }  }  else {    printf("Usage: %s <matrix_dimension> [random seed]\n",           argv[0]);        exit(0);  }  /* Print parameters */  printf("\nMatrix dimension N = %i.\n", N);}/* Initialize A and B*/void initialize_inputs() {  int row, col;  printf("\nInitializing...\n");   for (col = 0; col < N; col++) {    for (row = 0; row < N; row++) {      A[row][col] = (float)rand() / 32768.0;      B[row][col] = 0.0;    }  }  /*  for (col = 0; col < N; col++) {  	for (row = 0; row < N; row++) {		 A[row][col] = col + row;		  B[row][col] = 0.0;	}  }  */}/* Print input matrices */void print_inputs() {  int row, col;  if (N < 10) {    printf("\nA =\n\t");    for (row = 0; row < N; row++) {      for (col = 0; col < N; col++) {	    printf("%5.2f%s", A[row][col], (col < N-1) ? ", " : ";\n\t");      }    }  }}void print_B() {    int row, col;    // if (N < 10) {        printf("\nB =\n\t");        for (row = 0; row < N; row++) {            for (col = 0; col < N; col++) {                printf("%1.10f%s", B[row][col], (col < N-1) ? ", " : ";\n\t");            }        }    // }}int main(int argc, char **argv) {  /* Timing variables */  struct timeval etstart, etstop;  /* Elapsed times using gettimeofday() */  struct timezone tzdummy;  clock_t etstart2, etstop2;  /* Elapsed times using times() */  unsigned long long usecstart, usecstop;  struct tms cputstart, cputstop;  /* CPU times for my processes */  /* Process program parameters */  parameters(argc, argv);  /* Initialize A and B */  initialize_inputs();  /* Print input matrices */  print_inputs();  /* Start Clock */  printf("\nStarting clock.\n");  gettimeofday(&etstart, &tzdummy);  etstart2 = times(&cputstart);  /* Gaussian Elimination */  // matrixNorm();  matrixNorm_cuda();  /* Stop Clock */  gettimeofday(&etstop, &tzdummy);  etstop2 = times(&cputstop);  printf("Stopped clock.\n");  usecstart = (unsigned long long)etstart.tv_sec * 1000000 + etstart.tv_usec;  usecstop = (unsigned long long)etstop.tv_sec * 1000000 + etstop.tv_usec;  /* Display output */    print_B();  /* Display timing results */  printf("\nElapsed time = %g ms.\n",	 (float)(usecstop - usecstart)/(float)1000);  printf("(CPU times are accurate to the nearest %g ms)\n",	 1.0/(float)CLOCKS_PER_SEC * 1000.0);  printf("My total CPU time for parent = %g ms.\n",	 (float)( (cputstop.tms_utime + cputstop.tms_stime) -		  (cputstart.tms_utime + cputstart.tms_stime) ) /	 (float)CLOCKS_PER_SEC * 1000);  printf("My system CPU time for parent = %g ms.\n",	 (float)(cputstop.tms_stime - cputstart.tms_stime) /	 (float)CLOCKS_PER_SEC * 1000);  printf("My total CPU time for child processes = %g ms.\n",	 (float)( (cputstop.tms_cutime + cputstop.tms_cstime) -		  (cputstart.tms_cutime + cputstart.tms_cstime) ) /	 (float)CLOCKS_PER_SEC * 1000);      /* Contrary to the man pages, this appears not to include the parent */  printf("--------------------------------------------\n");    exit(0);}/* ------------------ Above Was Provided --------------------- *//****** You will replace this routine with your own parallel version *******//* Provided global variables are MAXN, N, A[][] and B[][], * defined in the beginning of this code.  B[][] is initialized to zeros. */void matrixNorm() {  int row, col;   float mu, sigma; // Mean and Standard Deviation  printf("Computing Serially.\n");    for (col=0; col < N; col++) {        mu = 0.0;        for (row=0; row < N; row++)            mu += A[row][col];        mu /= (float) N;        sigma = 0.0;        for (row=0; row < N; row++)            sigma += powf(A[row][col] - mu, 2.0);        sigma /= (float) N;        for (row=0; row < N; row++) {            if (sigma == 0.0)                B[row][col] = 0.0;            else                B[row][col] = (A[row][col] - mu) / sigma;        }    }}__global__ void kernal_function(float *a,float *b, int N){      int row = blockIdx.x * blockDim.x + threadIdx.x; //decide the threadId.      int i,j;      float mu, sigma;      if(row<N){        //calculate the mean        mu=0.0;        for(i=0;i<N;i++){          mu+=a[i*N+row];        }        mu/=(float)N;        //calculate the stand_deviation        sigma=0.0;        for(j=0;j<N;j++){          sigma+=powf((a[j*N+row]-mu),2.0);        }        sigma/=(float)N;        //calculate the normalized value        for(i=0;i<N;i++){          if(sigma==0.0)            b[i*N+row]=0.0;          else            b[i*N+row]=(a[i*N+row]-mu) /sigma;        }              }} void matrixNorm_cuda(){  int i;  float *d_A,*d_B;  float mu[N],sigma[N];  cudaMalloc((void **)&d_A,sizeof(int)*N*N); //allocate the memory to device_A  cudaMalloc((void **)&d_B,sizeof(int)*N*N);//allocate the memory to device_B  int BLOCKSIZE=1024;  //gpu parallel start  for(i=0;i<N;i++)  cudaMemcpy(d_A+i*N,(void*)&A[i][0],sizeof(float)*N,cudaMemcpyHostToDevice);//copy the data of host_A to device_A    double num = ceil(pow((double)N,2) / pow((double)BLOCKSIZE, 2));    int gridsize = (int)ceil(sqrt(num));    dim3 dimBlock(BLOCKSIZE, 1, 1);    dim3 dimGrid(gridsize, 1, 1);  kernal_function<<<dimGrid,dimBlock>>>(d_A,d_B,N);// execute the kernal function  for(i=0;i<N;i++){    cudaMemcpy((void*)&B[i][0],d_B+i*N,sizeof(float)*N,cudaMemcpyDeviceToHost);// copy back the data of device_A(calculated) to host_B  }  //gpu parallel stop  cudaFree(d_A);  cudaFree(d_B);}